В Компьютерной сети фирмы n компьютеров. В последнее время сеть работает нестабильно, поэтому не любые два компьютера могут связаться друг с другом. Известно, что если компьютер *a* обменивается информацией с компьютером *b*, то никакие другие компьютеры не могут в это время обмениваться информацией  ни с *a*, ни с *b*. Требуется определить максимальное количество компьютеров, которые могут одновременно участвовать в процессе обмена информацией.

Связь компьютеров задана матрицей смежности.

---

Если составить математическую модель задачи, то требуется найти наибольшее паросочетание в заданном графе. Т. е. требуется выбрать подмножество из множества вершин графа, такое что ребра между парами вершин этого подмножества образуют наибольшее паросочетание.

Для каждой вершины определим состояние: она либо связана с какой-то вершиной, либо свободна. Для фиксации этого факта будем использовать битовую маску. Т. е. множество задаётся  целым числом, у которого *i*-ый бит равен 0, если 
*i*-ая вершина свободна.

Определим функцию *f[mask]* как мощность наибольшего паросочетания в подграфе с вершинами из множества, которое описывает переменная *mask*.

Чтобы вычислить *f[mask]* рассмотрим любую вершину *i* из множества *mask*. Она либо свободна и тогда $f[mask] = f[mask - 2 ^ i]$ , либо связана с некоторой вершиной *j* , в таком случае $f[mask] = 1 + f[mask - 2^i - 2^j]$. Выбирается максимум из двух значений. Начальные условия задаются для пустого множества: $f[∅] = 0$ .

Порядок обхода подмножеств должен быть таков, чтобы при вычислении значения функции $f[mask]$ значения для соответствующих подмножеств были уже вычислены. Для этого подойдёт обычный цикл от 1 до $2^n$ - 1.

Сложность решения - $O(n * 2^n)$.

#### Псевдокод
```
n <- количество вершин в графе

Функция count_computers(graph, n):

	i <- 0, вершина графа

	f <- массив размером 2^n, инициализированный нулями. 
		 В него будем записывать количество компьютеров 
		 для каждого множества

	для каждого можества от 1 до (2^n - 1)
	
		для каждой вершины от 0 до (n - 1)         
			если вершина принадлежит множеству, то:               
				i <- j                  
				выйти из цикла
				            
		f[mask] <- f[mask - (1 << i)] - количество компьютеров, 
									   если вершина i свободна  
		   
		для каждого j от (i + 1) до (n - 1):         
			если компьюетры могут обмениваться информацией 
				 и вершина принадлежит множеству
			 то k <- f[mask - (1 << i) - (1 << j)] + 1 
			    f[mask] <- max(k, f[mask])

	вернуть f[(2^n) - 1] * 2
			     
```
#### Реализация на Python
```python
def count_computers(graph, n):  
    i = 0  
    f = [0] * (1 << n)  
  
    # Цикл по множествам  
    for mask in range(1, 1 << n):  
  
        # Цикл по вершинам множества  
        for j in range(0, n):  
  
            # Выбираем вершину i, которая принадлежит 
			# множеству mask  
            if mask & (1 << j):  
                i = j  
                break  
  
        # Если i-ая вершина свободна  
        f[mask] = f[mask - (1 << i)]  
  
        # Цикл по всем вершинам без i  
        for j in range(i + 1, n):  
  
            # Если i-тая вершина связана с j-ой вершиной  
            if graph[i][j] == 1 and (mask & (1 << j)):  
                k = f[mask - (1 << i) - (1 << j)] + 1  
  
                f[mask] = max(k, f[mask])  
  
    return f[(1 << n) - 1] * 2
```
#### Production C++
```cpp
int count_computers(std::vector<std::vector<int>> graph, 
					int size_graph) {  
    int node_from_set = 0;  
    std::vector<int> sets(1 << size_graph, 0);  
  
    // Цикл по множествам  
    for (int set = 1; set < (1 << size_graph); set++) {  
  
        // Цикл по вершинам множества  
        for (int node = 0; node < size_graph; node++) {  
  
            // Выбираем вершину которая принадлежит множеству  
            if (set & (1 << node)) {  
                node_from_set = node;  
                break;  
            }  
        }  
        // Если вершина свободна  
        sets[set] = sets[set - (1 << node_from_set)];  
  
        // Цикл по всем вершинам от node_from_set  
        for (int node = node_from_set + 1; 
	            node < size_graph; node++) {  
  
            // Если вершина из множества связана с другой вершиной  
            if (graph[node_from_set][node] == 1 
		             and (set & (1 << node))) {  
                int curr_count_computer = 
	            sets[set-(1<<node_from_set)-(1<<node)]+1;  
  
                sets[set] = std::max(curr_count_computer, 
				                      sets[set]);  
            }  
        }  
    }  
    return sets[(1 << size_graph) - 1] * 2;  
}
```
#### Olympic C++
```cpp
typedef vector<vector<int>> vvi;
typedef vector<int> vi;


int count_computers(vvi graph, int n) {
	int i = 0;  
	vi f(1 << n, 0);  
	
	for (int mask = 1; mask < (1 << n); mask++) {   
		for (int j = 0; j < n; j++) {  
			if (mask & (1 << j)) {  
				i = j;  
				break;  
			}  
		}  
        f[mask] = f[mask - (1 << i)];  
   
        for (int j = i + 1; j < n; j++) {  
            if (graph[i][j] == 1 and (mask & (1 << j))){  
                int k = f[mask - (1 << i) - (1 << j)] + 1;  
                f[mask] = max(k, f[mask]);  
            }  
        }  
    }  
    return f[(1 << n) - 1] * 2;  
}
```