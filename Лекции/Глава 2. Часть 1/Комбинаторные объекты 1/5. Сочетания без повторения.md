
## Описание

Сочетания без повторений - это важное комбинаторное понятие, которое находит применение в различных областях, таких как математика, информатика, статистика и другие. Давайте рассмотрим это понятие подробнее.

- _Определение_: Сочетания без повторений - это уникальные комбинации `k` элементов из заданного множества, в которых порядок элементов не имеет значения, и каждый элемент может встречаться только один раз.
    
- _Пример_: Пусть у нас есть множество {A, B, C, D}, и мы хотим получить все возможные сочетания из 2 элементов. Тогда такие сочетания будут: {A, B}, {A, C}, {A, D}, {B, C}, {B, D}, {C, D}.
    


## Формула сочетаний без повторений:

$$
\Huge{C(n, k) = \frac{{n!}}{{k! \cdot (n - k)!}}}

$$
- C(n,k) - количество сочетаний без повторений из n элементов, выбранных k элементов.
- n! - факториал числа n, что означает произведение всех положительных целых чисел от 1 до n.
- k! - факториал числа k.
- (n−k)! - факториал разницы между n и k.
  
  
  
## Применение

1. **Математика**:
	  Используются для решения комбинаторных задач и формулирования математических теорем.
    
2. **Информатика**:
	  Применяются в алгоритмах и структурах данных для обработки комбинаторных данных, например, в задачах перебора вариантов.
    
3. **Статистика**:
	  Применяются для анализа данных и расчета вероятностей.
    



## Функции для работы с сочетаниями без  повторений  Библиотека Algorithm (C++):

В C++, библиотека `<algorithm>` предоставляет функцию `next_combination()`, которая может быть использована для генерации сочетаний без повторений. Однако, эта функция не включена в стандартную библиотеку C++ и требует дополнительного кода для реализации.



## Функции для работы с сочетаниями без  повторений  Библиотека Itertools (Python):

В Python, библиотека `itertools` предоставляет функцию `combinations(iterable, r)`, которая генерирует все уникальные сочетания длины `r` из итерируемого объекта `iterable`. Эта функция удобна для работы с сочетаниями без повторений и включена в стандартную библиотеку Python.


## Псевдокод
```c++
Функция Вычислить_Сочетания_Без_Повторений(n, k):
    # Инициализируем результат
    результат <- 0
    
    # Проверяем, что n >= k, иначе результат остается нулем
    Если n >= k то:
        # Вычисляем C(n, k)
        результат <- Вычислить_Факториал(n) / (Вычислить_Факториал(k) * Вычислить_Факториал(n - k))
    
    Вернуть результат

Функция Вычислить_Факториал(x):
    # Инициализируем результат
    результат <- 1
    
    # Вычисляем факториал числа x
    Для каждого i от 1 до x:
        результат <- результат * i
    
    Вернуть результат

# Пример использования:
n <- 5  # Общее количество элементов
k <- 3  # Размер сочетания

результат <- Вычислить_Сочетания_Без_Повторений(n, k)
Вывести результат

```



## Python
```python
import math

def combinations_without_repetition(n, k):
    # Вычисляем C(n, k) с помощью формулы
    result = math.comb(n, k)
    return result

# Пример использования:
n = 5  # Общее количество элементов
k = 3  # Размер сочетания

result = combinations_without_repetition(n, k)
print(result)
```



## C++ Олимпиадный:
```c++
#include <iostream>

int main() {
    int n = 5;  // Общее количество элементов
    int k = 3;  // Размер сочетания

    long long result = 1;

    // Проверка, что n >= k
    if (n >= k) {
        long long numerator = 1;
        long long denominator = 1;

        // Вычисляем факториал n
        for (int i = 1; i <= n; i++) {
            numerator *= i;
        }

        // Вычисляем факториал k
        for (int i = 1; i <= k; i++) {
            denominator *= i;
        }

        // Вычисляем факториал (n - k)
        for (int i = 1; i <= (n - k); i++) {
            denominator *= i;
        }

        // Вычисляем количество сочетаний без повторений
        result = numerator / denominator;
    }

    std::cout << result << std::endl;

    return 0;
}
```



## C++ Продуктовый
```c++
#include <iostream>

// Функция для вычисления факториала
long long Factorial(int x) {
    long long result = 1;
    for (int i = 1; i <= x; i++) {
        result *= i;
    }
    return result;
}

// Функция для вычисления сочетаний без повторений C(n, k)
long long CalculateCombination(int n, int k) {
    long long result = 0;

    if (n >= k) {
        result = CalculateFactorial(n) / (CalculateFactorial(k) * CalculateFactorial(n - k));
    }

    return result;
}

int main() {
    int n = 5;  // Общее количество элементов
    int k = 3;  // Размер сочетания

    long long result = CalculateCombination(n, k);

    std::cout << result << std::endl;

    return 0;
}

```
