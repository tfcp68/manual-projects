Дана строка s. Требуется найти самый длинный палиндром, который можно получить из неё путём удаления символов.

1. Подзадачей будет являться поиск максимальной длины $p$ палиндрома, который можно получить из подстроки с $i$-го по $j$-ый символ оригинальной строки путём удаления символов

Для подстроки с $i$-го по $j$-ый символ возможный 3 варианта действий:
	1. Удаление $i$-го символа: для подстроки самым длинным палиндромом будет являться палиндром из подстроки с $(i+1)$-го по $j$-ый символ
	2. Удаление $j$-го символа: для подстроки самым длинным палиндромом будет являться палиндром из подстроки с $i$-го по $(j-1)$-ый символ
	3. Если $s[i] = s[j]$, то длина палиндрома будет равна $p[i-1][j-1]$ + 2

2. Рекуррентная формула
	1. $p[i][j] = максимум\;из\;p[i+1][j]\;и\;p[i][j-1]$
	2. Если $s[i] = s[j]$, то $p[i][j] = максимум\;из\;p[i][j]\;и\;p[i+1][j-1]+2$

3. Начальные значения: 
	1. $p[i-1][i]=0$ - значения для строк длины ноль 
	2. $p[i][i]=1$ - значения для строк длины один 

4. Значения хранятся в матрице размерности $[n][n]$, где n - длина строки
```
Псевдокод:
//p - матрица с необходимыми значениями
//s - оригинальная строка
//n - длина строки s

функция длинный_палиндром(s):
	заполнение главной диагонали матрицы p единицами
	для len_ от 1 до n:
		для i от 0 до (n-len_):
			j <- i + len_
			если s[i] = s[j], то
				p[i][j] = p[i + 1][j - 1] + 2
			иначе, то
				p[i][j] <- максимум из p[i + 1][j] и p[i][j - 1]
	вернуть p[0][n - 1]
``` 
```python
#python

def long_palindrome(str_: str):
    n = len(str_)
    p = [[0] * n for _ in range(n)]
    for i in range(n):
        p[i][i] = 1
    for len_ in range(1, n):
        for i in range(0, n - len_):
            j = i + len_
            if str_[i] == str_[j]:
                p[i][j] = p[i + 1][j - 1] + 2
            else:
                p[i][j] = max(p[i + 1][j], p[i][j - 1])
    return p[0][n - 1]
```
```cpp
//c++
//sport version

int long_palindrome(const string& l) {
    int n = l.length();
    int p[n][n];
    for (int i = 0; i < n; i++){
        p[i][i] = 1;
    }
    for (int len_ = 1; len_ < n; len_++){
        for (int i = 0; i < n - len_; i++){
            int j = i + len_;
            if (l[i] == l[j]){
                p[i][j] = p[i + 1][j - 1] + 2;
            }
            else{
                p[i][j] = max(p[i + 1][j], p[i][j - 1]);
            }
        }
    }
    return p[0][n - 1];
}
```
```cpp
//c++
//product version

template<typename ValueType>
ValueType long_palindrome(const string& line) {
    ValueType n = line.length();
    ValueType p[n][n];

    for (int i = 0; i < n; i++){
        p[i][i] = 1;
    }

    for (int len_ = 1; len_ < n; len_++){
        for (int i = 0; i < n - len_; i++){
            int j = i + len_;
            if (line[i] == line[j]){
                p[i][j] = p[i + 1][j - 1] + 2;
            }
            else{
                p[i][j] = std::max(p[i + 1][j], p[i][j - 1]);
            }
        }
    }
    return p[0][n - 1];
}