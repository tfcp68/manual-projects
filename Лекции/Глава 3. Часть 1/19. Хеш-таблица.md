
Хэш таблицы представляют собой структуры данных, используемые для эффективного хранения и извлечения данных. Они обеспечивают быстрый поиск, вставку и удаление элементов со сложностью $O(1)$. 

## Где используется

1. Реализация множества
2. Реализация ассоциативного контейнера
3. В базах данных в качестве индекса или системы хранения данных

## Из чего состоит

Хэш таблица состоит из 4 основных компонентов:

1. Хэш функция

Эта функция принимает входные данные и преобразует их в индекс в пределах заранее определённого диапазона. Цель хорошей хэш функции - равномерно распределить входные данные по диапазону индексов, чтобы минимизировать коллизии. Это необходимо для поддержания сложности операций $O(1)$.

2. Вычисление индексов

Если вы хотите сохранить или получить значение, связанное с ключом, к этому ключу применяется хэш функция для вычисления индекса. Этот индекс используется для определения того, где значение должно храниться или где его искать.

3. Массив корзин

Хэш таблицы обычно используют массив «корзин» для хранения значений. Каждая корзина может содержать одно или несколько значений. Индекс, рассчитанный с помощью хэш функции, указывает на конкретную корзину в массиве.

4. Разрешение коллизий

Коллизии возникают, когда хэш функция для различных входных данных возвращает одинаковые индексы. Для решения данной проблемы существуют механизмы обработки коллизий:

1) Цепи (Chaining):

Каждая корзина представляет собой последовательный контейнер (в основном связный список), в котором хранятся элементы с одинаковым хэшем.

2) Открытая адресация:

Все данные хранятся в массиве, каждая ячейка массива является корзина. При возникновении коллизии в массиве ищется подходящая (свободная или хранящая совпадающий элемент) ячейка в предопределённой последовательности индексов, заданной линейным или квадратичным зондированием.

### Линейное зондирование

При линейном зондировании, когда происходит коллизия, алгоритм ищет следующий доступный слот в линейной последовательности, увеличивая индекс на фиксированный шаг (обычно 1). Это продолжается до тех пор, пока не будет найден пустой слот или цикл не попадёт в ту же ячейку.

Например, при добавлении элемента $V$ для него был получен индекс $i$, по которому уже хранится значение. Тогда необходимо обратиться к ячейке с индексом $i + s$, если в ней находится элемент, то необходимо повторить операцию и обратиться к ячейке с индексом $i + 2s$, $i + 3s$ и т.д. Если подходящей позиции не будет найдено, то необходимо увеличить размер хэш таблицы и повторить операцию.

Линейное зондирование может привести к кластеризации, когда последовательные элементы располагаются в непосредственной близости, что может привести к снижению производительности.

### Квадратичное зондирование

При квадратичном зондировании последовательность зондирования определяется квадратичной функцией. При возникновении коллизии алгоритм увеличивает индекс на последовательно большие квадратичные шаги ($1^2, 2^2, 3^2, ...$), пока не будет найден пустой слот.
Это помогает распределить элементы более равномерно, чем линейное зондирование, но всё равно может привести к кластеризации.

3) Идеальное хэширование:

В данном подходе коллизии разрешаются их отсутствием. Выбирается такая хэш функция, которая будет возвращать для всех входных данных уникальный хэш. Данный способ стоит применять для известных входных данных, чтобы выбрать подходящую хэш функцию и размер массива для хранения элементов.

## Статическая и динамическая реализация

Статическая реализация хэш таблицы предполагает, что размер массива индексов в ней не изменяется, поэтому при добавлении большого количества элементов, сложность операций может повыситься до $O(n)$, где $n$ - количество элементов в структуре данных. Также, если весь массив корзин заполнится и в качестве алгоритма разрешения коллизий используется открытая адресация или идеальное хэширование, невозможно будет добавить новый элемент в структуру данных.

Динамическая реализация хэш таблицы позволяет избежать проблем, существующих у статической реализации, за счёт увеличения используемой оперативной памяти.

Также при увеличении размера структуры данных, необходимо создать новый массив корзин увеличенного размера и скопировать в него данные хранящиеся в хэш таблице данные, поэтому сложность такой операции будет равняться $O(n)$.

Если увеличение размера таблицы возникает во время добавления элемента, то сложность этой операции также будет составлять $O(n)$. Но амортизированная сложность операции добавления будет составлять $O(1)$ по аналогии с динамическим массивом.

## Коэффициент загрузки

Коэффициент загрузки хэш таблицы - это отношение количества хранимых элементов к количеству корзин. Высокий коэффициент загрузки может привести к увеличению числа коллизий, снижая производительность. Для поддержания эффективности размер хэш таблиц можно изменить (увеличить количество корзин), когда коэффициент загрузки становится слишком высоким.

Идеальный коэффициент загрузки хэш таблицы для увеличения её размера, независимо от алгоритма обработки коллизий, обычно составляет ~$0.7$. Это означает, что хэш таблица заполнена примерно на $70\%$.

При таком коэффициенте загрузки хэш таблица имеет оптимальный баланс между использованием оперативной памяти и сохранением производительности.

Данный коэффициент загрузки для увеличения размера структуры данных позволяет:

1. Минимизировать коллизии
2. Содержать достаточное количество пустых корзин для избежания чрезмерной кластеризации
3. Иметь оптимальную сложность по памяти

Важно отметить, что оптимальный коэффициент загрузки может изменяться в зависимости от таких факторов, как:

1. Выбранная хэш функция
2. Способ распределения данных
3. Качество алгоритма разрешения коллизий
4. Множитель увеличения размера массива корзин

## Выбор множителя увеличения размера массива корзин

При выборе множителя увеличения размера массива корзин следует руководствоваться требованиями к структуре данных: допустимой сложностью операций и максимальной пространственной сложностью.

Оптимальным коэффициентом расширения структуры данных является $2$ (аналогично динамическому массиву). Если необходимо минимизировать расход оперативной памяти, то следуем выбирать коэффициент $(1; 2]$. Если необходимо максимизировать производительность операций, то коэффициент следует сделать большим (оптимально $4$).

## Реализация хэш таблицы

### Реализация метода разрешения коллизий на основе цепей

#### Псевдокод

```
структура Цепная Хэш Таблица:
	типы данных:
		Элемент
		Корзина = список элементов
		Таблица = Массив корзин

	атрибуты:
		hash_func - хэш функция для элементов
		table - таблица хранимых данных
		size - количество хранимых элементов

	методы:
		добавить элемент(Элемент x):
			если необходимо расширить таблицу:
				расширить таблицу
			index = hash_func(x) - вычисление индекса корзины
			bucket = значение из table по индексу index
			- проверка, что элемента в корзине не существует
			для элемента y в корзине bucket:
				если x совпадает с y:
					завершить выполнение функции
			добавить элемент x в корзину bucket
			увеличить size на 1

		удалить элемент(Элемент x):
			index = hash_func(x)
			bucket = значение из table по индексу index
			для элемента y в корзине bucket:
				если x совпадает с y:
					удалить y из корзины bucket
					уменьшить size на 1
					завершить выполнение функции

		проверить содержание элемента(Элемент x) -> true/false:
			index = hash_func(x)
			bucket = значение из table по индексу index
			для элемента y в корзине bucket:
				если x совпадает с y:
					вернуть true
			вернуть false
```

#### C++

Подключение необходимых библиотек:

```cpp
#include <functional>  // для std::hash
#include <list>  // корзина
#include <vector>  // массив корзин
```

Реализация итератора по таблице:

```cpp
template <
    typename ReferenceType,
    typename TableIterator,
    typename BucketIterator>
class ChainingHashTableIterator {
public:
    typedef std::remove_reference_t<ReferenceType> value_type;
    typedef ReferenceType reference;
    typedef value_type* pointer;
    typedef std::ptrdiff_t difference_type;
    typedef std::forward_iterator_tag iterator_category;

private:
    typedef TableIterator table_iterator;
    typedef typename table_iterator::value_type bucket;
    typedef typename bucket::iterator bucket_iterator;

public:
    // конструкторы, деструктор и операторы присваивания
    ChainingHashTableIterator(
        table_iterator table_it,
        table_iterator table_end,
        bucket_iterator bucket_it) : _table_it(table_it),
                                     _table_end(table_end),
                                     _bucket_it(bucket_it) {
        // необходимо проитерироваться от
        // начального итератора _table_it до первого
        // встретившегся элемента
        if (_table_it != _table_end and _bucket_it == _table_it->end())
            ++(*this);
    }

    ChainingHashTableIterator(const ChainingHashTableIterator& other) = default;

    ChainingHashTableIterator(ChainingHashTableIterator&& other) = default;

    ~ChainingHashTableIterator() = default;

    ChainingHashTableIterator& operator=(const ChainingHashTableIterator& other) = default;

    ChainingHashTableIterator& operator=(ChainingHashTableIterator&& other) = default;

    // операции доступа к элементу
    reference operator*() const {
        return *_bucket_it;
    }

    pointer operator->() const {
        return &(*_bucket_it);
    }

    // операции инкремента
    ChainingHashTableIterator& operator++() {
        // алгоритм перехода:
        // следуем вперёд по корзине
        // если корзина пройдена, то нужно перейти к следующей
        // не пустой корзине
        ++_bucket_it;
        if (_bucket_it == _table_it->end()) {
            ++_table_it;
            while (_table_it != _table_end and _table_it->empty())
                ++_table_it;
            if (_table_it != _table_end)
                _bucket_it = _table_it->begin();
        }
        return *this;
    }

    ChainingHashTableIterator operator++(int) {
        ChainingHashTableIterator tmp(*this);
        ++(*this);
        return tmp;
    }

    // операторы сравнения
    bool operator==(const ChainingHashTableIterator& other) const {
        return this->_is_end() and other._is_end() or _table_it == other._table_it and _bucket_it == other._bucket_it;
    }

    bool operator==(ChainingHashTableIterator&& other) const {
        return this->operator==(other);
    }

    bool operator!=(const ChainingHashTableIterator& other) const {
        return !(*this == other);
    }

    bool operator!=(ChainingHashTableIterator&& other) const {
        return this->operator!=(other);
    }

private:
    bool _is_end() const {
        return _table_it == _table_end;
    }

private:
    // текущий итератор по массиву корзин и конец массива корзин
    table_iterator _table_it, _table_end;
    // итератор по корзине
    bucket_iterator _bucket_it;
};
```

Реализация хэш таблицы:

```cpp
// аргументы шаблона:
// аналогичны реализации на цепочках
// Probing - функция генерации индексов
// последовательности открытой адресации
template <
    typename ValueType,
    typename EqOperator = std::equal_to<ValueType>,
    typename Probing = QuadraticProbing<std::size_t>,
    typename Hash = std::hash<ValueType>>
class OpenAddressingHashTable {
public:
    typedef ValueType value_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef std::ptrdiff_t difference_type;
    typedef Hash hash_type;
    typedef Probing probing_type;
    typedef EqOperator equal_type;
    typedef std::size_t size_type;

private:
    typedef OpenAddressingHashTableBucket<value_type> bucket;
    typedef std::vector<bucket> table;

public:
    typedef OpenAddressingHashTableIterator<reference, typename table::iterator> iterator;
    typedef OpenAddressingHashTableIterator<const_reference, typename table::const_iterator> const_iterator;

public:
    // конструкторы, деструктор и операторы присваивания
    // аргументы аналогичны реализации на цепочках
    // probing - функция генерации последовательности
    // открытой адресации
    OpenAddressingHashTable(
        size_type default_capacity = 10,
        const hash_type& hash = hash_type(),
        const probing_type& probing = probing_type(),
        const equal_type& eq = equal_type(),
        double max_load_factor = 0.7,
        double rehash_multiplier = 2.0) : _size(0), _table(default_capacity), _hash(hash), _probing(probing), _eq(eq), _max_load_factor(max_load_factor), _rehash_multiplier(rehash_multiplier) {}

    OpenAddressingHashTable(const OpenAddressingHashTable& other) = default;

    OpenAddressingHashTable(OpenAddressingHashTable&& other) = default;

    ~OpenAddressingHashTable() = default;

    OpenAddressingHashTable& operator=(const OpenAddressingHashTable& other) = default;

    OpenAddressingHashTable& operator=(OpenAddressingHashTable&& other) = default;

    // геттеры
    size_type size() const {
        return this->_size;
    }

    bool empty() const {
        return this->_size == 0;
    }

    double load_factor() const {
        return static_cast<double>(this->_size) / this->_table.size();
    }

    // основные функции
    // операция вставки
    void insert(const value_type& value) {
        // элемент может уже храниться в структуре
        // поэтому сначала нужно попытаться найти уже существующий элемент
        auto iter = this->find(value);
        if (iter != this->end()) {
            *iter = value;
            return;
        }
        // если структура загружена
        // или не найден индекс для вставки
        // нужно расширить массив корзин
        if (this->load_factor() > this->_max_load_factor)
            this->_rehash();
        auto index = this->_find_index(value, true);
        if (index >= this->_table.size()) {
            this->_rehash();
            this->insert(value);
            return;
        }
        auto& bucket = this->_table[index];
        bucket.set_value(value);
        ++this->_size;
    }

    void insert(value_type&& value) {
        auto iter = this->find(value);
        if (iter != this->end()) {
            *iter = std::move(value);
            return;
        }
        if (this->load_factor() > this->_max_load_factor)
            this->_rehash();
        auto index = this->_find_index(value, true);
        if (index >= this->_table.size()) {
            this->_rehash();
            this->insert(value);
            return;
        }
        auto& bucket = this->_table[index];
        bucket.set_value(std::move(value));
        ++this->_size;
    }

    // операция удаления
    // возвращает true, если элемент был удалён
    // false, если элемент не был найден
    bool erase(const value_type& value) {
        auto index = this->_find_index(value);
        if (index >= this->_table.size())
            return false;
        auto& bucket = this->_table[index];
        if (not bucket)
            return false;
        bucket.erase();
        --this->_size;
        return true;
    }

    bool erase(value_type&& value) {
        return this->erase(value);
    }

    // операция проверки на содержание элемента
    // возвращает true, если value хранится в структуре
    // данных, иначе false
    bool contains(const value_type& value) const {
        auto index = this->_find_index(value);
        if (index >= this->_table.size())
            return false;
        auto& bucket = this->_table[index];
        return bool(bucket);
    }

    bool contains(value_type&& value) const {
        return this->contains(value);
    }

    // операция очистки таблицы
    void clear() {
        for (auto& bucket : this->_table)
            bucket.erase();
        this->_size = 0;
    }

    // операции получения итератора на value
    // если value не найден, то вернётся end()
    iterator find(const value_type& value) {
        auto index = this->_find_index(value);
        if (index >= this->_table.size() or not this->_table[index])
            return this->end();
        return {this->_table.begin() + index, this->_table.end()};
    }

    iterator find(value_type&& value) {
        return this->find(value);
    }

    const_iterator find(const value_type& value) const {
        auto index = this->_find_index(value);
        if (index >= this->_table.size() or not this->_table[index])
            return this->cend();
        return {this->_table.cbegin() + index,
                this->_table.cend()};
    }

    const_iterator find(value_type&& value) const {
        return this->find(value);
    }

    // операции итераторов
    iterator begin() {
        return {this->_table.begin(), this->_table.end()};
    }

    iterator end() {
        return {this->_table.end(), this->_table.end()};
    }

    const_iterator cbegin() const {
        return {this->_table.begin(), this->_table.end()};
    }

    const_iterator cend() const {
        return {this->_table.end(), this->_table.end()};
    }

private:
    // операция расширения таблицы
    void _rehash() {
        size_type new_size = _table.size() * _rehash_multiplier;
        table new_table(new_size);
        // перенос всех непустых элементов
        // в новый массив корзин
        for (auto& bucket : _table) {
            if (bucket) {
                auto index = _hash(*bucket) % new_size;
                size_type iteration = 0;
                while (new_table[index]) {
                    index = _probing(index, iteration);
                    ++iteration;
                }
                new_table[index] = std::move(bucket);
            }
        }
        _table = std::move(new_table);
    }

    // операция поиска подходящей позиции для элемента
    // возвращает индекс подходящей корзины для value
    // виды возвращаемых индексов:
    // 1. индекс, выходящий за пределы массива корзин
    // 2. корзина по индексу пуста
    // 3. в корзине по индексу находится value
    size_type _find_index(const value_type& value, bool for_add = false) const {
        size_type index = _hash(value) % _table.size();
        size_type iteration = 1;
        while (index < this->_table.size()) {
            auto& bucket = _table[index];
            if (for_add and bucket.can_set())
                return index;
            else if (bucket.state() == bucket::state_type::EMPTY or
                     bucket.state() == bucket::state_type::OCCUPIED and
                         _eq(*bucket, value))
                return index;
            index = _probing(index, iteration);
            ++iteration;
        }
        return index;
    }

private:
    size_type _size;
    table _table;
    hash_type _hash;
    probing_type _probing;
    equal_type _eq;
    double _max_load_factor;
    double _rehash_multiplier;
};
```

#### Python 3

```python
from collections import deque
from typing import Hashable


class ChainingHashTable:
    def __init__(self,
                 default_capacity=10,
                 max_load_factor=0.7,
                 resize_factor=2):
        self._size = 0
        self._table = [deque() for _ in range(default_capacity)]
        self._max_load_factor = max_load_factor
        self._resize_factor = resize_factor

    def __len__(self):
        return self._size

    def __contains__(self, value):
        index = self._hash(value)
        return value in self._table[index]

    def __iter__(self):
        for bucket in self._table:
            for item in bucket:
                yield item

    def __eq__(self, other):
        if len(self) != len(other):
            return False
        for item in self:
            if item not in other:
                return False
        return True

    def load_factor(self) -> float:
        return self._size / len(self._table)

    def add(self, value: Hashable):
        if self.load_factor() > self._max_load_factor:
            self._resize()
        index = self._hash(value)
        for i, item in enumerate(self._table[index]):
            if item == value:
                self._table[index][i] = value
                return
        self._table[index].append(value)
        self._size += 1

    def remove(self, value: Hashable) -> bool:
        index = self._hash(value)
        if value not in self._table[index]:
            return False
        self._table[index].remove(value)
        self._size -= 1
        return True

    def _hash(self, item) -> int:
        return hash(item) % len(self._table)

    def _resize(self):
        new_size = int(len(self._table) * self._resize_factor)
        new_table = [deque() for _ in range(new_size)]
        for bucket in self._table:
            for item in bucket:
                index = hash(item) % new_size
                new_table[index].append(item)
        self._table = new_table
```

### Реализация метода разрешения коллизий на основе открытой адресации

#### Псевдокод

```
структура Хэш Таблица с открытой адресацией:
	типы данных:
		Элемент
		Таблица = массив элементов

	атрибуты:
		hash_func - хэш функция для элементов
		addr_func - функция для генерации последовательности
					открытой адресации
		table - таблица хранимых данных
		size - количество хранимых элементов

	методы:
		найти позицию(Элемент x) -> индекс:
			base_index = hash_func(x) - базовый индекс для x
			если в table по индексу base_index существует элемент,
												совпадающий с x:
				вернуть base_index
			step = 1 - шаг последовательности открытой адресации
			pos = addr_func(index, step) - первая позиция 
							последовательности открытой адресации
			пока pos не совпадает с base_index:
				если в table по индексу pos существует элемент, 
						совпадающий с x ИЛИ в table по индексу pos
						не существует элемента:
					вернуть pos
			вернуть несуществующий индекс

		добавить элемент(Элемент x):
			index = найти позицию(x)
			если index - несуществующий индекс:
				расширить таблицу
				добавить элемент(x)
				завершить выполнение функции
			установить в table на позицию index элемент x
			увеличить размер на 1

		удалить элемент(Элемент x):
			index = найти позицию(x)
			если index - несуществующий индекс ИЛИ элемент на 
					позиции index в table не совпадает с x:
				завершить выполнение функции
			удалить элемент в table на позиции index

		проверить содержание элемента(Элемент x) -> true/false:
			index = найти позицию(x)
			если index - несуществующий индекс ИЛИ элемент на
					позиции index в table не совпадает с x:
				вернуть false
			вернуть true
```

#### C++

Подключение необходимых библиотек:

```cpp
#include <functional>  // для std::hash
#include <vector>      // для массива корзин
```

Реализация функторов зондирования:

Интерфейс зондирования:

```cpp
template <typename IndexType>
struct Probing {
    typedef IndexType index_type;

    virtual ~Probing() = default;

    virtual index_type operator()(index_type start,
                                  index_type iteration) const = 0;
};
```

Реализация линейного зондирования:

```cpp
template <
    typename IndexType = std::size_t,
    typename AddFunction = std::plus<IndexType>,
    typename MultiplyFunction = std::multiplies<IndexType>>
struct LinearProbing : Probing<IndexType> {
    using index_type = typename Probing<IndexType>::index_type;
    typedef AddFunction add_type;
    typedef MultiplyFunction multiply_type;

    LinearProbing(
        index_type step = 1,
        add_type add_func = add_type(),
        multiply_type multiply_func = multiply_type()) : step(step), add_func(add_func), multiply_func(multiply_func) {}

    index_type operator()(index_type start,
                          index_type iteration) const override {
        return add_func(start, multiply_func(step,
                                             iteration));
    }

private:
    index_type step;
    add_type add_func;
    multiply_type multiply_func;
};
```

Реализация квадратичного зондирования:

```cpp
template <
    typename IndexType = std::size_t,
    typename AddFunction = std::plus<IndexType>,
    typename MultiplyFunction = std::multiplies<IndexType>>
struct QuadraticProbing : Probing<IndexType> {
    using index_type = typename Probing<IndexType>::index_type;
    typedef AddFunction add_type;
    typedef MultiplyFunction multiply_type;

    QuadraticProbing(
        index_type step = 1,
        add_type add_func = add_type(),
        multiply_type multiply_func = multiply_type()) : step(step), add_func(add_func), multiply_func(multiply_func) {}

    index_type operator()(index_type start,
                          index_type iteration) const override {
        auto value = multiply_func(step, iteration);
        return add_func(start, multiply_func(value, value));
    }

private:
    index_type step;
    add_type add_func;
    multiply_type multiply_func;
};
```

Реализация корзины:

```cpp
template <typename ValueType>
struct OpenAddressingHashTableBucket {
    enum OpenAddressingHashTableBucketState {
        EMPTY,
        DELETED,
        OCCUPIED,
    };

    typedef ValueType value_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef OpenAddressingHashTableBucketState state_type;

    // конструкторы, деструктор и операторы присваивания
    OpenAddressingHashTableBucket() : _ptr(nullptr), _state(state_type::EMPTY) {}

    OpenAddressingHashTableBucket(const value_type& value) : _ptr(new value_type(value)), _state(state_type::OCCUPIED) {}

    OpenAddressingHashTableBucket(value_type&& value) : _ptr(new value_type(std::move(value))), _state(state_type::OCCUPIED) {}

    OpenAddressingHashTableBucket(const OpenAddressingHashTableBucket& other) : _ptr(new value_type(*other._ptr)), _state(other._state) {}

    OpenAddressingHashTableBucket(OpenAddressingHashTableBucket&& other) : _ptr(other._ptr), _state(other._state) {
        other._ptr = nullptr;
    }

    ~OpenAddressingHashTableBucket() {
        delete _ptr;
    }

    OpenAddressingHashTableBucket& operator=(const OpenAddressingHashTableBucket& other) {
        if (this != &other) {
            delete _ptr;
            _ptr = new value_type(*other._ptr);
            _state = other._state;
        }
        return *this;
    }

    OpenAddressingHashTableBucket& operator=(OpenAddressingHashTableBucket&& other) {
        if (this != &other) {
            delete _ptr;
            _ptr = other._ptr;
            other._ptr = nullptr;
            _state = other._state;
        }
        return *this;
    }

    // геттеры и сеттеры
    state_type state() const {
        return this->_state;
    }

    reference operator*() {
        return *_ptr;
    }

    const_reference operator*() const {
        return *_ptr;
    }

    void set_value(const value_type& value) {
        if (_ptr == nullptr)
            _ptr = new value_type(value);
        else
            *_ptr = value;
        _state = state_type::OCCUPIED;
    }

    void set_value(value_type&& value) {
        if (_ptr == nullptr)
            _ptr = new value_type(std::move(value));
        else
            *_ptr = std::move(value);
        _state = state_type::OCCUPIED;
    }

    // удалить значение в корзине
    void erase() {
        delete _ptr;
        _ptr = nullptr;
        _state = state_type::DELETED;
    }

    // функции проверки состояния корзины
    operator bool() const {
        return _state == state_type::OCCUPIED;
    }

    bool can_set() const {
        return _state == state_type::EMPTY or _state == state_type::DELETED;
    }

private:
    pointer _ptr;
    state_type _state;
};
```

Реализация итератора:

```cpp
// аргументы шаблона:
// ReferenceType - тип ссылки на объект (обычная или const)
// TableIterator - тип итератора по массиву корзин
template <
    typename ReferenceType,
    typename TableIterator>
class OpenAddressingHashTableIterator {
public:
    typedef std::remove_reference_t<ReferenceType> value_type;
    typedef ReferenceType reference;
    typedef value_type* pointer;
    typedef std::ptrdiff_t difference_type;
    typedef std::forward_iterator_tag iterator_category;

private:
    typedef TableIterator table_iterator;
    typedef typename table_iterator::value_type bucket;

public:
    // конструкторы, деструктор и операторы присваивания
    OpenAddressingHashTableIterator(table_iterator it, table_iterator end) : _it(it), _end(end) {
        // необходимо дошагать до первой встретившейся
        // корзины, хранящей значение
        while (_it != _end and not *_it)
            ++_it;
    }

    OpenAddressingHashTableIterator(const OpenAddressingHashTableIterator& other) = default;

    OpenAddressingHashTableIterator(OpenAddressingHashTableIterator&& other) = default;

    ~OpenAddressingHashTableIterator() = default;

    OpenAddressingHashTableIterator& operator=(const OpenAddressingHashTableIterator& other) = default;

    OpenAddressingHashTableIterator& operator=(OpenAddressingHashTableIterator&& other) = default;

    // операции доступа к элементу
    reference operator*() {
        return **_it;
    }

    pointer operator->() {
        return &**_it;
    }

    // операции инкремента
    OpenAddressingHashTableIterator& operator++() {
        ++_it;
        while (_it != _end and not *_it)
            ++_it;
        return *this;
    }

    OpenAddressingHashTableIterator operator++(int) {
        auto tmp = *this;
        ++*this;
        return tmp;
    }

    // операции сравнения
    bool operator==(const OpenAddressingHashTableIterator& other) const {
        return _it == other._it;
    }

    bool operator==(OpenAddressingHashTableIterator&& other) const {
        return _it == other._it;
    }

    bool operator!=(const OpenAddressingHashTableIterator& other) const {
        return !(*this == other);
    }

    bool operator!=(const OpenAddressingHashTableIterator&& other) const {
        return !(*this == other);
    }

private:
    table_iterator _it, _end;
};
```

Реализация хэш таблицы:

```cpp
// аргументы шаблона:
// аналогичны реализации на цепочках
// Probing - функция генерации индексов
// последовательности открытой адресации
template <
    typename ValueType,
    typename EqOperator = std::equal_to<ValueType>,
    typename Probing = QuadraticProbing<std::size_t>,
    typename Hash = std::hash<ValueType>>
class OpenAddressingHashTable {
public:
    typedef ValueType value_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef std::ptrdiff_t difference_type;
    typedef Hash hash_type;
    typedef Probing probing_type;
    typedef EqOperator equal_type;
    typedef std::size_t size_type;

private:
    typedef OpenAddressingHashTableBucket<value_type> bucket;
    typedef std::vector<bucket> table;

public:
    typedef OpenAddressingHashTableIterator<reference, typename table::iterator> iterator;
    typedef OpenAddressingHashTableIterator<const_reference, typename table::const_iterator> const_iterator;

public:
    // конструкторы, деструктор и операторы присваивания
    // аргументы аналогичны реализации на цепочках
    // probing - функция генерации последовательности
    // открытой адресации
    OpenAddressingHashTable(
        size_type default_capacity = 10,
        const hash_type& hash = hash_type(),
        const probing_type& probing = probing_type(),
        const equal_type& eq = equal_type(),
        double max_load_factor = 0.7,
        double rehash_multiplier = 2.0) : _size(0), _table(default_capacity), _hash(hash), _probing(probing), _eq(eq), _max_load_factor(max_load_factor), _rehash_multiplier(rehash_multiplier) {}

    OpenAddressingHashTable(const OpenAddressingHashTable& other) = default;

    OpenAddressingHashTable(OpenAddressingHashTable&& other) = default;

    ~OpenAddressingHashTable() = default;

    OpenAddressingHashTable& operator=(const OpenAddressingHashTable& other) = default;

    OpenAddressingHashTable& operator=(OpenAddressingHashTable&& other) = default;

    // геттеры
    size_type size() const {
        return this->_size;
    }

    bool empty() const {
        return this->_size == 0;
    }

    double load_factor() const {
        return static_cast<double>(this->_size) / this->_table.size();
    }

    // основные функции
    // операция вставки
    void insert(const value_type& value) {
        // элемент может уже храниться в структуре
        // поэтому сначала нужно попытаться найти уже существующий элемент
        auto iter = this->find(value);
        if (iter != this->end()) {
            *iter = value;
            return;
        }
        // если структура загружена
        // или не найден индекс для вставки
        // нужно расширить массив корзин
        if (this->load_factor() > this->_max_load_factor)
            this->_rehash();
        auto index = this->_find_index(value, true);
        if (index >= this->_table.size()) {
            this->_rehash();
            this->insert(value);
            return;
        }
        auto& bucket = this->_table[index];
        bucket.set_value(value);
        ++this->_size;
    }

    void insert(value_type&& value) {
        auto iter = this->find(value);
        if (iter != this->end()) {
            *iter = std::move(value);
            return;
        }
        if (this->load_factor() > this->_max_load_factor)
            this->_rehash();
        auto index = this->_find_index(value, true);
        if (index >= this->_table.size()) {
            this->_rehash();
            this->insert(value);
            return;
        }
        auto& bucket = this->_table[index];
        bucket.set_value(std::move(value));
        ++this->_size;
    }

    // операция удаления
    // возвращает true, если элемент был удалён
    // false, если элемент не был найден
    bool erase(const value_type& value) {
        auto index = this->_find_index(value);
        if (index >= this->_table.size())
            return false;
        auto& bucket = this->_table[index];
        if (not bucket)
            return false;
        bucket.erase();
        --this->_size;
        return true;
    }

    bool erase(value_type&& value) {
        return this->erase(value);
    }

    // операция проверки на содержание элемента
    // возвращает true, если value хранится в структуре
    // данных, иначе false
    bool contains(const value_type& value) const {
        auto index = this->_find_index(value);
        if (index >= this->_table.size())
            return false;
        auto& bucket = this->_table[index];
        return bool(bucket);
    }

    bool contains(value_type&& value) const {
        return this->contains(value);
    }

    // операция очистки таблицы
    void clear() {
        for (auto& bucket : this->_table)
            bucket.erase();
        this->_size = 0;
    }

    // операции получения итератора на value
    // если value не найден, то вернётся end()
    iterator find(const value_type& value) {
        auto index = this->_find_index(value);
        if (index >= this->_table.size() or not this->_table[index])
            return this->end();
        return {this->_table.begin() + index, this->_table.end()};
    }

    iterator find(value_type&& value) {
        return this->find(value);
    }

    const_iterator find(const value_type& value) const {
        auto index = this->_find_index(value);
        if (index >= this->_table.size() or not this->_table[index])
            return this->cend();
        return {this->_table.cbegin() + index,
                this->_table.cend()};
    }

    const_iterator find(value_type&& value) const {
        return this->find(value);
    }

    // операции итераторов
    iterator begin() {
        return {this->_table.begin(), this->_table.end()};
    }

    iterator end() {
        return {this->_table.end(), this->_table.end()};
    }

    const_iterator cbegin() const {
        return {this->_table.begin(), this->_table.end()};
    }

    const_iterator cend() const {
        return {this->_table.end(), this->_table.end()};
    }

private:
    // операция расширения таблицы
    void _rehash() {
        size_type new_size = _table.size() * _rehash_multiplier;
        table new_table(new_size);
        // перенос всех непустых элементов
        // в новый массив корзин
        for (auto& bucket : _table) {
            if (bucket) {
                auto index = _hash(*bucket) % new_size;
                size_type iteration = 0;
                while (new_table[index]) {
                    index = _probing(index, iteration);
                    ++iteration;
                }
                new_table[index] = std::move(bucket);
            }
        }
        _table = std::move(new_table);
    }

    // операция поиска подходящей позиции для элемента
    // возвращает индекс подходящей корзины для value
    // виды возвращаемых индексов:
    // 1. индекс, выходящий за пределы массива корзин
    // 2. корзина по индексу пуста
    // 3. в корзине по индексу находится value
    size_type _find_index(const value_type& value, bool for_add = false) const {
        size_type index = _hash(value) % _table.size();
        size_type iteration = 1;
        while (index < this->_table.size()) {
            auto& bucket = _table[index];
            if (for_add and bucket.can_set())
                return index;
            else if (bucket.state() == bucket::state_type::EMPTY or
                     bucket.state() == bucket::state_type::OCCUPIED and
                         _eq(*bucket, value))
                return index;
            index = _probing(index, iteration);
            ++iteration;
        }
        return index;
    }

private:
    size_type _size;
    table _table;
    hash_type _hash;
    probing_type _probing;
    equal_type _eq;
    double _max_load_factor;
    double _rehash_multiplier;
};
```
#### Python 3

```python
from enum import Enum
from typing import Hashable, Any
from dataclasses import dataclass


def linear_probing(index, iteration, step=1):
    return index + step * iteration


def quadratic_probing(index, iteration, step=1):
    return index + ((step * iteration) ** 2)


@dataclass
class OpenAddressingHashTableBucket:
    class State(Enum):
        EMPTY = 0
        DELETED = 1
        OCCUPIED = 2

    value: Hashable = None
    state: State = State.EMPTY

    def __bool__(self):
        return self.state == self.State.OCCUPIED

    def set(self, value):
        self.value = value
        self.state = self.State.OCCUPIED

    def clear(self):
        self.value = None
        self.state = self.State.DELETED

    def can_set(self) -> bool:
        return self.state in (self.State.DELETED, self.State.EMPTY)


class OpenAddressingHashTable:
    Bucket = OpenAddressingHashTableBucket

    def __init__(self,
                 default_capacity=10,
                 max_load_factor=0.7,
                 resize_factor=2,
                 probing_function=quadratic_probing):
        self._size = 0
        self._table = [self.Bucket() for _ in range(default_capacity)]
        self._max_load_factor = max_load_factor
        self._resize_factor = resize_factor
        self._probing_function = probing_function

    def __len__(self):
        return self._size

    def __contains__(self, value):
        index = self._find_index(value)
        if index >= len(self._table):
            return False
        bucket = self._table[index]
        return bool(bucket)

    def __iter__(self):
        for bucket in self._table:
            if bucket:
                yield bucket.value

    def __eq__(self, other):
        if len(self) != len(other):
            return False
        for item in self:
            if item not in other:
                return False
        return True

    def load_factor(self) -> float:
        return self._size / len(self._table)

    def add(self, value: Hashable):
        if self._add_existing(value):
            return
        if self.load_factor() > self._max_load_factor:
            self._resize()
        index = self._find_index(value, for_add=True)
        if index >= len(self._table):
            self._resize()
            return self.add(value)
        bucket = self._table[index]
        bucket.set(value)
        self._size += 1

    def remove(self, value: Hashable) -> bool:
        index = self._find_index(value)
        if index >= len(self._table):
            return False
        bucket = self._table[index]
        if not bucket:
            return False
        bucket.clear()
        self._size -= 1
        return True

    def get(self, value: Hashable) -> Any:
        index = self._find_index(value)
        if index >= len(self._table) or not self._table[index]:
            raise KeyError(f"{value} not found")
        return self._table[index].value

    def _add_existing(self, value: Hashable) -> bool:
        index = self._find_index(value)
        if index >= len(self._table):
            return False
        bucket = self._table[index]
        if bucket:
            bucket.set(value)
            return True
        return False

    def _find_index_for_addition(self, value: Hashable) -> int:
        index = self._hash(value)
        step = 1
        result_index = len(self._table)
        while index < len(self._table):
            bucket = self._table[index]
            if bucket.state == self.Bucket.State.OCCUPIED and bucket.value == value:
                return index
            elif bucket.can_set() and result_index == len(self._table):
                result_index = index
            index = self._probing_function(index, step)
            step += 1
        return result_index

    def _find_index(self, value: Hashable, for_add=False) -> int:
        index = self._hash(value)
        step = 1
        while index < len(self._table):
            bucket = self._table[index]
            if for_add and bucket.can_set():
                return index
            elif (bucket.state == self.Bucket.State.EMPTY or
                  bucket.state == self.Bucket.State.OCCUPIED and
                  bucket.value == value
                  ):
                return index
            index = self._probing_function(index, step)
            step += 1
        return index

    def _hash(self, item) -> int:
        return hash(item) % len(self._table)

    def _resize(self):
        new_size = int(len(self._table) * self._resize_factor)
        new_table = [self.Bucket() for _ in range(new_size)]
        for bucket in self._table:
            if bucket:
                index = hash(bucket.value) % new_size
                iteration = 0
                while new_table[index]:
                    index = self._probing_function(index, iteration)
                    iteration += 1
                new_table[index] = bucket
        self._table = new_table
```
