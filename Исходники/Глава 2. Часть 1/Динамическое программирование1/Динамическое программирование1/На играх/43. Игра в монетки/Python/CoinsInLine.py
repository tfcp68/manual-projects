

def first_step(n, coins, dp, path):
    for i in range(n):
        dp[i][i] = coins[i]
        path[i][i] = str(coins[i])

    for i in range(n - 1):
        dp[i][i + 1] = max(coins[i], coins[i + 1])
        path[i][i + 1] = str(dp[i][i + 1])

    return dp, path


def coin_in_line(coins):
    n = len(coins)
    dp = [[0] * n for _ in range(n)]
    path = [[''] * n for _ in range(n)]

    dp, path = first_step(n, coins, dp, path)

    for gap in range(2, n):
        for i in range(n - gap):
            j = i + gap

            choose_left = coins[i] + min(dp[i + 2][j], dp[i + 1][j - 1])
            choose_right = coins[j] + min(dp[i + 1][j - 1], dp[i][j - 2])
            dp[i][j] = max(choose_left, choose_right)

            if choose_left > choose_right:
                path[i][j] += f'{coins[i]} {path[i + 2][j]}'
            else:
                path[i][j] = f'{coins[j]} {path[i][j - 2]}'

    return dp[0][n - 1], path[0][n - 1]


# Для определения оптимальной стратегии Алисы мы можем использовать подход динамического программирования.
# Определим функцию dp(i, j), которая представляет собой максимальную сумму денег,
# которую может получить Алиса, если монеты будут от i до j.

# Сначала необходимо инициализировать dp(i, i) = values[i], поскольку Алиса может выбрать только монету с индексом i.

# Затем мы можем заполнить значения dp(i, j), используя следующее рекуррентное соотношение:
# dp(i, j) = max(values[i] + min(dp(i+2, j), dp(i+1, j-1)), values[j] + min(dp(i+1, j-1), dp(i, j-2))).

# Это уравнение представляет собой два возможных варианта выбора Алисы:
# Если Алиса выберет монету в позиции i, то Боб выберет монету в позиции i+1 или j.
# Если Боб выберет i+1, то Алисе останутся монеты от i+2 до j.
# Если Боб выберет j, то Алисе останутся монеты от i+1 до j-1.
# Алиса выберет минимальный из этих двух вариантов и добавит к нему стоимость монеты в позиции i.

# Если Алиса выберет монету в позиции j, то Боб выберет либо монету в позиции i, либо j-1.
# Если Боб выберет i, то Алиса останется с монетами от i+1 до j-1.
# Если Боб выберет j-1, то Алиса останется с монетами от i до j-2.
# Алиса выберет минимальный из этих двух вариантов и добавит стоимость монеты в позиции j.
#
# В итоге ответ на задачу будет dp(0, n-1), где n - количество монет.
# Временная сложность этого решения составляет O(n^2), поскольку мы перебираем все возможные подзадачи.