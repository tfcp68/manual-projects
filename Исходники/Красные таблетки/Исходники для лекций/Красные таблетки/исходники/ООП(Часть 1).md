ООП - Объектно-Ориентированное Программирование


### Что все люди путают:
1. Class - объявили, когда его объявили это класс.Когда создаем переменную это объект/экземпляр класса.


### ООП хар-ется 3мя вещами:

1. Инкапсуляция - (от слова Капсула) - Обертка для того чтобы внутри и вне "не смешается". В каких-то моментах доступ должен быть, а в каких-то нет. Доступ к вашему объекту/не допуск.
2. Полиморфизм - (Поли Морфизм) - много форм - можете с разным кодом(есть много форм кода)
3. Наследование - (хорошая практика - то расширение объектов, а не дополнения) - Если нужно расширить, то как ? Мы добавляем данные и функции.
   Как сделать без проблем ?
   Наследование!
   У нас есть вектор xy и у него есть методы добавить и удалить.
   Мы хотим сделать 2 класс у которого должно быть добавить удалить, разность и симметричная разность. Тогда и приходит наследование.
   Наследование позволяет не дублировать код, а максимально использовать уже написанный код -> Меньше кода = Меньше ошибок.


### Интерфейс - описание класса по его действиям.

<< Пример про DB.... >>


### Самая важная вещь:

Абстрактные классы и Интерфейсы говорят что нужно сделать, но не говорит как.
Проектирование на уровне интерфейсов -> Реализация на уровне классов.


### SOLID
Дает хорошие ивристики(правила) для написания хорошего ООП кода.

В нем 5 принципов:

- S - single responsibility principle - Принцип одной ответственности - один класс - одна отвественность. Антипаттерн - объект Бога. Много классов - меньше сильной связности. Пример реализации - нарезка обхектов.

- O - open-closed principle - Принцип Открытости/Закрытости. - Сущности открыты для расширения, но закрыты для изменения.Полезли в старый код - ошибка на проектировании.

- L -  Liskov substitution principle - Принип Подстановки Барбары Лесков - функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа не зная об этом - Дочерний класс должен расширять, а не замещать базовый класс.
  

- I  - interface segregation principle - Принцип разделение на интерфейсов - Связана с проектированием, после проектирования пишем интерфейсы - потом пришем классы что там и потом только реализации.

- D - dependency inversion principle - Принцип - Принцип инверсии зависимостей - Модули высокого уровня не должны зависить от моделей более низкого уровня. Все должны зависеть от абстракции, а абстракции не зависить от реализации. Реализация - зависит от абстракции.

В данном принципе нужен баланс между сложностью и простотой с точки зрения ответсвенности.

<< Пример про вектор... >>

Нам нужно минимальными классами и в будущем выдерживали минимальные изменения.
